#![allow(clippy::let_and_return)]

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{UnorderedMap, UnorderedSet};
use near_sdk::{
    env, near_bindgen, AccountId, Balance, BorshStorageKey, Gas, PanicOnDefault, Promise, PublicKey,
};

pub mod error;

pub use error::Error;

// TODO: discuss a function grant_extra_funds where this
// AccountManager could grant extra funds to some users,
// even if they already existed

pub const KILO: u64 = 1000;
pub const MEGA: u64 = KILO * KILO;
pub const TERA: u64 = MEGA * MEGA;
pub const YOTTA: u128 = (TERA as u128) * (TERA as u128);

#[near_sdk::ext_contract(ext_self)]
pub trait ExtSelf {
    fn on_account_created(account_id: AccountId, account_public_key: PublicKey) -> bool;
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Accounts,
    AccountsQueue,
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct AccountManager {
    /// Owner of this account.
    pub owner: AccountId,
    // Accounts that were successfuly created.
    pub accounts: UnorderedMap<AccountId, PublicKey>,
    /// Accounts that have been asked to be created.
    pub accounts_queue: UnorderedSet<AccountId>,
    /// Initial amount to attach to created accounts.
    pub initial_amount: Balance,
}

#[near_bindgen]
impl AccountManager {
    #[init]
    pub fn new(owner: AccountId, initial_amount: Balance) -> Self {
        Self {
            owner,
            accounts: UnorderedMap::new(StorageKey::Accounts),
            accounts_queue: UnorderedSet::new(StorageKey::AccountsQueue),
            initial_amount,
        }
    }

    pub fn create_account(
        &mut self,
        // The sub-account that is being created.
        // Expected to have be a sub-account on `AccountManager`.
        account_id: AccountId,
        // TODO: this pubkey is currently not used
        //
        // TODO: Add this pubkey but not as `full_access_key`
        // otherwise the users could immediately drain the attached deposit
        // on the sub-accounts.
        //
        // suggestion: users must return all the funds they ever received
        // from `AccountManager` in order to gain full privilege
        // over the sub-account.
        // TODO: keep track of everything they received from `AccountManager`
        // TODO: allow the user to call a method on `AccountManager`,
        // that allows attaching deposits, and that would update
        // how much the user has returned to the `AccountManager`.
        // Then when the user finish returning everything they
        // have received, this public key would be registered as
        // `full_access_key` to the sub-account, and the
        // `AccountManager` should be unregistered from it.
        //
        // The PublicKey of the sub-account being created.
        // Expected to be generated by the user.
        account_public_key: PublicKey,
    ) -> Promise {
        const GAS_CURRENT: Gas = Gas(5 * TERA);
        let gas = env::prepaid_gas() - env::used_gas() - GAS_CURRENT;

        if self.owner != env::predecessor_account_id() {
            Error::NotOwner.panic()
        }

        let is_new_account = self.accounts_queue.insert(&account_id);
        if !is_new_account {
            Error::AccountAlreadyQueued.panic()
        }

        let wallet_standard_owner = env::signer_account_pk();

        let call = Promise::new(account_id.clone())
            .create_account()
            .add_full_access_key(wallet_standard_owner)
            .transfer(self.initial_amount)
            .then(ext_self::on_account_created(
                account_id,
                account_public_key,
                env::current_account_id(),
                0u128,
                gas,
            ));

        call
    }

    #[private]
    pub fn on_account_created(
        &mut self,
        account_id: AccountId,
        account_public_key: PublicKey,
    ) -> bool {
        if env::promise_results_count() != 1 {
            Error::BadCallbackResults.panic()
        }

        let success: Option<bool> = match env::promise_result(0) {
            near_sdk::PromiseResult::Successful(v) => {
                // did not encounter any panicking failure,
                // but could still fail (false)
                Some(near_sdk::serde_json::from_slice(&v).unwrap())
            }
            // encountered some panicking failure
            _ => None,
        };

        if let Some(true) = success {
            let did_exist = self.accounts_queue.remove(&account_id);
            // sanity check
            assert!(did_exist);

            let previous_element = self.accounts.insert(&account_id, &account_public_key);
            // sanity check
            assert!(previous_element.is_none());

            env::log_str(&format!("account {} created.", account_id));
        }

        // TODO: on `success` = Some(false), remove account from the queue?
        // TODO: on `success` = None, keep the account in the queue?

        // returns false on `success` = None
        success.unwrap_or_default()
    }
}
