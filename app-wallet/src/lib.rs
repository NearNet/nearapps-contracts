#![allow(clippy::let_and_return)]

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedSet;
use near_sdk::json_types::U128;
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, Gas, PanicOnDefault, Promise, PublicKey,
};
use near_units::parse_gas;
use nearapps_near_ext::ensure;

pub mod error;
pub mod logging;
pub mod owners;
pub mod version;

pub use error::Error;

#[near_sdk::ext_contract(ext_self)]
pub trait ExtSelf {
    fn on_subaccount_created(config: AccountConfig) -> bool;
    fn on_account_created(new_account_id: AccountId) -> bool;
}

#[near_sdk::ext_contract(ext_parent)]
pub trait ExtParent {
    fn create_account(new_account_id: AccountId, new_public_key: PublicKey) -> bool;
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Accounts,
    AccountsQueue,
    Owners,
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct AccountManager {
    /// Owners of this account.
    pub owner_ids: UnorderedSet<AccountId>,
    pub nearapps_logger: AccountId,
    // Accounts that were successfuly created.
    pub accounts: UnorderedSet<AccountId>,
    /// Accounts that have been asked to be created.
    pub accounts_queue: UnorderedSet<AccountId>,
    // pub defaults: Defaults,
}

#[derive(
    near_sdk::serde::Serialize, near_sdk::serde::Deserialize, BorshDeserialize, BorshSerialize,
)]
#[serde(crate = "near_sdk::serde")]

pub struct Defaults {
    /// The default initial amount to attach to created accounts.
    pub initial_amount: U128,
    /// The default allowance to attach to allowed calls on created
    /// accounts.
    pub allowance: U128,
    /// The default allowed calls that new accounts are able to make.
    pub allowed_calls: Vec<AllowedCalls>,
}

#[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountConfig {
    /// The sub-account that is being created.
    /// Expected to be a sub-account on `AccountManager`.
    pub account_id: AccountId,
    /// The PublicKey of the sub-account being created.
    /// Expected to be generated by the user.
    pub user_public_key: PublicKey,
    // /// The initial amount of deposit that the user should receive.
    // ///
    // /// If missing, the user will receive
    // /// [`Defaults::initial_amount`]
    // pub initial_amount: Option<U128>,
}

#[derive(
    near_sdk::serde::Serialize,
    near_sdk::serde::Deserialize,
    BorshDeserialize,
    BorshSerialize,
    Clone,
)]
#[serde(crate = "near_sdk::serde")]
pub struct AllowedCalls {
    /// How much, in total, the user can spend when calling the contract.
    ///
    /// For each call for the given contract, the allowance will be
    /// decreasing as deposits and gas gets used by the call.
    ///
    /// For replenishment or increase of the allowance, the access_key
    /// must be removed and then added again, with the new `allowance`
    /// value.
    ///
    /// If missing, the value [`Defaults::allowance`]
    /// is used.
    pub allowance: Option<U128>,
    /// The contract address that the user is allowed to call into.
    pub receiver_id: AccountId,
    /// List of method names (eg. `["method_a", "method_b"]`) that the user
    /// is allowed to call.  
    ///
    /// An empty list means all methods.
    pub method_names: Vec<String>,
}

#[near_bindgen]
impl AccountManager {
    #[init]
    pub fn new(owner_id: AccountId, nearapps_logger: AccountId) -> Self {
        ensure(!env::state_exists(), Error::AlreadyInitialized);
        let mut owner_ids = UnorderedSet::new(StorageKey::Owners);
        owner_ids.insert(&owner_id);
        Self {
            owner_ids,
            nearapps_logger,
            accounts: UnorderedSet::new(StorageKey::Accounts),
            accounts_queue: UnorderedSet::new(StorageKey::AccountsQueue),
        }
    }

    /// Creates a new user account.
    ///
    /// By default [`env::signer_account_pk()`] will be the full owner
    /// of the new account, unless `user_manager_public_key` is present.
    ///
    /// The accounts, while being created, first enter a queue from which
    /// they are removed once the successfull creation has been
    /// confirmed.  
    /// The created account names are then tracked in [`AccountManager::accounts`].
    #[payable]
    pub fn create_account(
        &mut self,
        new_account_id: AccountId,
        new_public_key: Option<PublicKey>,
    ) -> Promise {
        // simulation
        // const _GAS_CURRENT: Gas = Gas(21 * TERA);
        // const GAS_CREATE_ACC_CALL: Gas = Gas(4 * TERA);
        // const GAS_CALLBACK: Gas = Gas(500_000 * MEGA);

        // testnet
        const _GAS_CURRENT: Gas = Gas(parse_gas!("13 Tgas") as u64);
        const GAS_CREATE_ACC_CALL: Gas = Gas(parse_gas!("11 Tgas") as u64);
        const GAS_CALLBACK: Gas = Gas(parse_gas!("8 Tgas") as u64);

        self.assert_owner();

        let user_manager_public_key = new_public_key.unwrap_or_else(env::signer_account_pk);

        let is_new_account = self.accounts_queue.insert(&new_account_id);
        ensure(is_new_account, Error::AccountAlreadyQueued);

        let user_account_id_str = new_account_id.to_string();
        let (user, parent) = user_account_id_str.split_once('.').unwrap();
        let _sub_user: AccountId = user.parse().unwrap();
        let parent: AccountId = parent.parse().unwrap();

        let new_acc = ext_parent::create_account(
            new_account_id.clone(),
            user_manager_public_key,
            parent,
            env::attached_deposit(),
            GAS_CREATE_ACC_CALL,
        );
        let callback = ext_self::on_account_created(
            new_account_id,
            env::current_account_id(),
            0u128,
            GAS_CALLBACK,
        );

        new_acc.then(callback)
    }

    #[private]
    pub fn on_account_created(&mut self, user_account_id: AccountId) -> bool {
        ensure(env::promise_results_count() == 1, Error::BadCallbackResults);

        let success: Option<bool> = match env::promise_result(0) {
            near_sdk::PromiseResult::Successful(v) => {
                // did not encounter any panicking failure
                let res: bool = near_sdk::serde_json::from_slice(&v).unwrap();
                Some(res)
            }
            // encountered some panicking failure
            _ => None,
        };

        // TODO: test when the AccountManager doesn't have enough
        // funds, if it falls into this case
        //
        // TODO: could the call still be ongoing?
        // not sure if it can be removed from the queue here
        match success {
            Some(true) => {
                let did_exist = self.accounts_queue.remove(&user_account_id);
                // sanity check
                assert!(did_exist);

                let did_exist = !self.accounts.insert(&user_account_id);
                // sanity check
                assert!(!did_exist);

                env::log_str(&format!("account {} created.", user_account_id));
            }
            Some(false) => {
                let did_exist = self.accounts_queue.remove(&user_account_id);
                // sanity check
                assert!(did_exist);
            }
            None => {
                // some error occurred
                let did_exist = self.accounts_queue.remove(&user_account_id);
                // sanity check
                assert!(did_exist);
            }
        }

        success.unwrap_or_default()
    }
}
